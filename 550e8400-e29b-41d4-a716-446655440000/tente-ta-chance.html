<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tentes ta chance — Grattage</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        :root{
            --mauve-1: #2b0b2f;
            --mauve-2: #3b0f4a;
            --violet-deep: #190824;
            --emerald: #00c38a;
            --electric-blue: #00a8ff;
            --mustard: #d4a017;
            --text: #efe9ff;
            --muted: rgba(255,255,255,0.14);
        }
        html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;color:var(--text);}
        body{background: linear-gradient(160deg,var(--mauve-1) 10%, var(--mauve-2) 60%, var(--violet-deep) 100%);display:flex;align-items:center;justify-content:center;padding:36px;}
        .container{width:100%;max-width:820px}
        .scratch-wrap{position:relative;width:100%;height:380px;border-radius:12px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,0.5)}
        .reveal{position:absolute;inset:0;z-index:1;background:linear-gradient(180deg,#3b0f4a,#2b0b2f);display:flex;align-items:center;justify-content:center;padding:24px;text-align:center}
        .reveal h1{font-family:'Playfair Display',serif;font-size:28px;margin:0;color:var(--text)}
        .overlay{position:absolute;inset:0;background:linear-gradient(90deg,#c9a94b,#f3d98a);display:block;cursor:crosshair}
        .back-link{display:inline-block;margin-bottom:14px;color:var(--muted);text-decoration:none}
    </style>
</head>
<body>
    <div class="container">
        <a class="back-link" href="index.html">← Retour</a>
        <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
            <h2 style="font-family:'Playfair Display',serif;margin:6px 0 0">Tentes ta chance</h2>
            <button id="auto-scratch" style="margin-left:auto;padding:8px 12px;border-radius:8px;border:none;background:var(--mustard);color:#1a1110;font-weight:600;cursor:pointer">Grattage automatique</button>
        </div>
        <div class="scratch-wrap" id="lux-scratch">
            <div class="reveal" id="reveal">
                <img id="reveal-image" src="image/reveal-image.png" alt="Dommage, pas maintenant !" style="width:100%;height:100%;object-fit:cover;border-radius:6px;filter:blur(6px);transition:filter .3s ease;position:relative;z-index:1">
                <!-- reveal-text replaced by an image so it can be styled/blurred the same way as the background -->
                <img id="reveal-text" src="image/reveal-text.jpg" alt="Veux-tu m'épouser ?" style="display:block;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:2;margin:0;font-family:'Playfair Display',serif;font-size:32px;color:rgba(255,241,200,0.95);text-shadow:0 2px 8px rgba(0,0,0,0.6);filter:blur(6px);transition:filter .3s ease;pointer-events:none;max-width:80%;height:auto;border-radius:6px">
            </div>
            <!-- canvas pour couche à gratter -->
            <canvas class="overlay" id="scratcher" style="position:absolute;inset:0;z-index:3"></canvas>
            <!-- canvas pour particules -->
            <canvas id="particles" style="position:absolute;inset:0;pointer-events:none;z-index:4"></canvas>
        </div>
    </div>

    <script>
        // Luxe scratch implementation: textured gold overlay, filigrane, particles, coin cursor
        (function(){
            const canvas = document.getElementById('scratcher');
            const pCanvas = document.getElementById('particles');
            const wrap = document.getElementById('lux-scratch');
            const revealImage = document.getElementById('reveal-image');
            const revealText = document.getElementById('reveal-text');

            // coin cursor SVG data URL
            const coinSvg = encodeURIComponent(`
                <svg xmlns='http://www.w3.org/2000/svg' width='48' height='48' viewBox='0 0 48 48'>
                  <defs>
                    <radialGradient id='g' cx='30%' cy='30%'><stop offset='0' stop-color='%23FFE98A'/><stop offset='1' stop-color='%23E1AD01'/></radialGradient>
                  </defs>
                  <circle cx='24' cy='24' r='20' fill='url(%23g)' stroke='%23C48A00' stroke-width='2'/>
                  <g fill='%23fff' opacity='0.9'><circle cx='20' cy='18' r='2'/><path d='M22 30c1-4 6-4 7 0' stroke='%23FFF' stroke-width='1.5' fill='none'/></g>
                </svg>
            `);
            wrap.style.cursor = `url("data:image/svg+xml;utf8,${coinSvg}") 24 24, auto`;

            // style wrap border + glow
            wrap.style.border = '3px solid rgba(0,200,140,0.95)';
            wrap.style.boxShadow = '0 8px 30px rgba(0,168,255,0.12), 0 0 40px rgba(0,168,255,0.06)';
            wrap.style.borderRadius = '12px';
            wrap.style.position = 'relative';

            // sizes (with devicePixelRatio handling for crisp canvas and correct coordinates)
            function resize(){
                const w = wrap.clientWidth; const h = wrap.clientHeight;
                const dpr = window.devicePixelRatio || 1;
                // set CSS size
                canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
                pCanvas.style.width = w + 'px'; pCanvas.style.height = h + 'px';
                // set backing store size
                canvas.width = Math.round(w * dpr); canvas.height = Math.round(h * dpr);
                pCanvas.width = Math.round(w * dpr); pCanvas.height = Math.round(h * dpr);
                // scale contexts so drawing uses CSS pixels
                const ctx = canvas.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
                const pp = pCanvas.getContext('2d'); pp.setTransform(dpr,0,0,dpr,0,0);
                drawOverlay();
            }

            // offscreen pattern for filigrane (hearts/dentelle)
            function createFiligreePattern(w,h){
                const off = document.createElement('canvas'); off.width = 120; off.height = 120; const octx = off.getContext('2d');
                octx.clearRect(0,0,off.width,off.height);
                octx.fillStyle = 'rgba(255,255,255,0.08)';
                // simple lace: circles + small hearts
                for(let y=20;y<off.height;y+=30){ for(let x=20;x<off.width;x+=30){ octx.beginPath(); octx.arc(x,y,3,0,Math.PI*2); octx.fill(); }}
                // hearts
                octx.fillStyle = 'rgba(255,245,200,0.06)';
                function heart(cx,cy,sz){ octx.beginPath(); const s=sz/2; octx.moveTo(cx,cy); octx.bezierCurveTo(cx,cy-s, cx-s,cy-s, cx-s,cy); octx.bezierCurveTo(cx-s,cy+s, cx,cy+s*1.4, cx,cy+sz); octx.bezierCurveTo(cx,cy+s*1.4, cx+s,cy+s, cx+s,cy); octx.bezierCurveTo(cx+s,cy-s, cx,cy-s, cx,cy); octx.fill(); }
                heart(40,40,8); heart(80,80,6);
                return octx.createPattern(off,'repeat');
            }

            let filigreePattern = null;

            // Reconstruct an obfuscated reveal date (keeps the literal date less obvious in source)
            let _targetReveal = null;
            function getTargetReveal(){
                if(_targetReveal) return _targetReveal;
                // These numbers reconstruct: year=2026, month=8, day=6, hour=22
                const parts = [ (2000 + 26), (8), (6), (22), 0, 0 ];
                _targetReveal = new Date(parts[0], parts[1]-1, parts[2], parts[3], parts[4], parts[5]);
                return _targetReveal;
            }

            // helper: are we at or past the reveal date?
            function isRevealDatePassed(){
                const now = new Date();
                return now >= getTargetReveal();
            }

            // show/hide reveal image vs reveal text depending on the date
            function updateRevealVisibility(){
                if(isRevealDatePassed()){
                    // show final text image on top
                    revealText.style.display = 'block';
                    revealText.style.visibility = 'visible';
                    revealText.style.opacity = '1';
                    revealImage.style.display = 'block';
                    revealImage.style.visibility = 'visible';
                } else {
                    // show placeholder image only
                    revealText.style.display = 'none';
                    revealText.style.visibility = 'hidden';
                    revealText.style.opacity = '0';
                    revealImage.style.display = 'block';
                    revealImage.style.visibility = 'visible';
                }
            }

            function drawOverlay(){
                const ctx = canvas.getContext('2d');
                // clear full HiDPI canvas
                ctx.clearRect(0,0,canvas.width,canvas.height);
                const rect = canvas.getBoundingClientRect();
                // brushed-metal / gold gradient (use CSS dimensions)
                const g = ctx.createLinearGradient(0,0, rect.width, rect.height);
                g.addColorStop(0,'#E1AD01'); g.addColorStop(0.6,'#F3D56A'); g.addColorStop(1,'#FFEAA0');
                ctx.fillStyle = g; ctx.fillRect(0,0, rect.width, rect.height);

                // subtle grain / glitter (CSS space)
                const grainCount = Math.floor((rect.width*rect.height)/8000);
                ctx.fillStyle = 'rgba(255,255,255,0.06)';
                for(let i=0;i<grainCount;i++){ const x=Math.random()*rect.width; const y=Math.random()*rect.height; ctx.fillRect(x, y, Math.random()*1.6, Math.random()*1.6); }

                // filigree pattern
                if(!filigreePattern) filigreePattern = createFiligreePattern(rect.width, rect.height);
                ctx.globalAlpha = 0.10; ctx.fillStyle = filigreePattern; ctx.fillRect(0,0,rect.width,rect.height); ctx.globalAlpha = 1;

                // subtle noise overlay for brushed effect
                ctx.fillStyle = 'rgba(0,0,0,0.02)';
                for(let i=0;i<2000;i++){ const x=Math.random()*rect.width; const y=Math.random()*rect.height; ctx.fillRect(x,y,Math.random()*0.8,Math.random()*0.8); }

                // ensure subsequent drawing uses destination-out to erase
                ctx.globalCompositeOperation = 'destination-out';
            }

            // particles
            const particles = [];
            const pctx = pCanvas.getContext('2d');
            function spawnParticles(x,y){
                for(let i=0;i<6;i++){ particles.push({x,y,vx:(Math.random()-0.5)*3,vy:-Math.random()*2-1,life:60,sz:Math.random()*3+1,alpha:1}); }
            }
            function updateParticles(){
                pctx.clearRect(0,0,pCanvas.width,pCanvas.height);
                for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.08; p.life--; p.alpha = p.life/60; pctx.fillStyle = `rgba(255,223,77,${p.alpha})`; pctx.beginPath(); pctx.arc(p.x,p.y,p.sz,0,Math.PI*2); pctx.fill(); if(p.life<=0) particles.splice(i,1); }
                requestAnimationFrame(updateParticles);
            }

            // drawing (erasing) and clearing detection
            function getPos(e){
                const r = canvas.getBoundingClientRect();
                const point = (e.touches && e.touches[0]) ? e.touches[0] : e;
                const xCss = point.clientX - r.left;
                const yCss = point.clientY - r.top;
                const dpr = canvas.width / r.width;
                return { x: xCss * dpr, y: yCss * dpr };
            }

            let drawing=false;
            function drawAt(x,y,sz=28){
                const ctx = canvas.getContext('2d');
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.fillStyle = 'rgba(0,0,0,1)';
                ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI*2); ctx.fill();
                ctx.restore();
                // spawn particles in CSS pixel coords
                const r = canvas.getBoundingClientRect(); const dpr = canvas.width / r.width;
                spawnParticles(x / dpr, y / dpr);
            }

            function pointerDown(e){ drawing=true; const p=getPos(e); drawAt(p.x,p.y,28); }
            function pointerMove(e){ if(!drawing) return; e.preventDefault(); const p=getPos(e); drawAt(p.x,p.y,28); }
            function pointerUp(e){ drawing=false; checkClear(); }

            function checkClear(){
                try{
                    const ctx = canvas.getContext('2d');
                    const img = ctx.getImageData(0,0,canvas.width,canvas.height).data;
                    let cleared = 0;
                    for(let i = 3; i < img.length; i += 4){ if(img[i] === 0) cleared++; }
                    const pct = cleared / (canvas.width * canvas.height);
                    // adjust blur during progress
                    const maxBlur = 6; const blur = Math.max(0, maxBlur * (1 - pct));
                    revealImage.style.filter = `blur(${blur}px)`;
                    revealText.style.filter = `blur(${blur}px)`;

                            if(pct > 0.35){ // finished enough to reveal
                                // toggle which reveal asset to show based on date
                                if(isRevealDatePassed()){
                                    // reveal the final text image
                                    revealText.style.display = 'block';
                                    revealText.style.zIndex = 10;
                                    revealText.style.filter = 'blur(0px)';
                                    revealText.style.opacity = '1';
                                    revealImage.style.filter = 'blur(0px)';
                                } else {
                                    // keep showing the placeholder image with final clarity
                                    revealText.style.display = 'none';
                                    revealImage.style.filter = 'blur(0px)';
                                }
                                canvas.style.transition = 'opacity .6s';
                                canvas.style.opacity = '0';
                                setTimeout(()=>canvas.style.display = 'none', 700);
                            }
                }catch(e){ console.warn(e); }
            }

            // events
            function addListeners(){
                canvas.addEventListener('pointerdown', pointerDown, {passive:true});
                window.addEventListener('pointerup', pointerUp, {passive:true});
                canvas.addEventListener('pointermove', pointerMove, {passive:false});
                // support touch
                canvas.addEventListener('touchstart', e=>{ pointerDown(e.touches[0]); }, {passive:true});
                canvas.addEventListener('touchmove', e=>{ pointerMove(e.touches[0]); }, {passive:false});
                window.addEventListener('resize', resize);
            }

            // Auto-scratch implementation
            const autoBtn = document.getElementById('auto-scratch');
            let autoInterval = null;
            function autoScratch(duration = 2000){
                // simulate many small scratch strokes across the canvas over `duration` ms
                const steps = Math.max(30, Math.floor(duration / 16));
                let count = 0;
                autoBtn.disabled = true; autoBtn.style.opacity = '0.7';
                autoInterval = setInterval(()=>{
                    // draw several strokes per tick for speed
                    const w = canvas.width, h = canvas.height;
                    for(let s=0;s<6;s++){
                        // spiral-like pattern from center outward
                        const t = (count*6 + s) / steps;
                        const angle = t * Math.PI * 8;
                        const radius = Math.min(w,h) * (t*0.6 + Math.random()*0.02);
                        const x = w/2 + Math.cos(angle) * radius + (Math.random()-0.5)*30;
                        const y = h/2 + Math.sin(angle) * radius + (Math.random()-0.5)*20;
                        drawAt(x,y, 28 + Math.random()*8);
                    }
                    count++;
                    if(count >= steps){ clearInterval(autoInterval); autoInterval = null; autoBtn.disabled=false; autoBtn.style.opacity='1'; checkClear(); }
                }, Math.max(8, Math.floor(duration/steps)) );
            }

            autoBtn.addEventListener('click', ()=> autoScratch(2000));

            // gate interactivity behind the stored rendezvous key
            const HASH_EXPECTED = '561f2d42ea28b8e600dcd1fe3fb9ace2739907331487f00fdba6196806606c42';
            let codeValide = false;
            try{
                const stored = (localStorage.getItem('rendezvous-auth') || sessionStorage.getItem('rendezvous-auth') || '').toLowerCase();
                if(stored === HASH_EXPECTED) codeValide = true;
            }catch(e){ /* storage possibly blocked */ }

            // If the code is not valid, disable interactions on the canvas and auto button
            if(!codeValide){
                canvas.style.pointerEvents = 'none';
                autoBtn.disabled = true; autoBtn.style.opacity = '0.5';
                // still draw overlay so user sees placeholder
                resize(); updateParticles(); updateRevealVisibility();
            } else {
                // start interactive flows
                resize(); updateParticles(); addListeners(); updateRevealVisibility();
            }

        })();
    </script>
</body>
</html>